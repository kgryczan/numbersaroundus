<div>

# Symphony of Structures: A Journey through List-Columns and Nested Data Frames with purrr {#symphony-of-structures-a-journey-through-list-columns-and-nested-data-frames-with-purrr .p-name}

</div>

::: {.section .p-summary field="subtitle"}
Overture: Introduction
:::

::::::::::: {.section .e-content field="body"}
:::::: {#1078 .section .section .section--body .section--first}
::: section-divider

------------------------------------------------------------------------
:::

:::: section-content
::: {.section-inner .sectionLayout--insetColumn}
### Symphony of Structures: A Journey through List-Columns and Nested Data Frames with purrr {#e9a9 .graf .graf--h3 .graf--leading .graf--title name="e9a9"}

<figure id="82b3" class="graf graf--figure graf-after--h3">
<img
src="https://cdn-images-1.medium.com/max/800/1*TCOojh8G-ogRb2Kfvuelcg.jpeg"
class="graf-image" data-image-id="1*TCOojh8G-ogRb2Kfvuelcg.jpeg"
data-width="1024" data-height="768" data-is-featured="true" />
</figure>

#### Overture: Introduction {#d6eb .graf .graf--h4 .graf-after--figure name="d6eb"}

Just as a symphony's overture sets the tone for the entire performance,
so too does our introduction provide an overview of what's to come. Much
like an orchestra is composed of different sections --- each with their
unique characteristics --- data in R can be complex, having different
layers and structures. Today, we'll be delving into the magic of
list-columns and nested data frames, two aspects of the purrr package
that can sometimes seem as intricate and detailed as a beautifully
crafted symphony.

Whether you're just starting to compose your first few notes in R, or
you're a seasoned conductor of data analysis, navigating these
structures is crucial. When data is layered within itself, like a melody
within a melody, it can become a bit daunting. But fear not --- by the
end of this post, you will have the necessary knowledge to conduct your
way through even the most complex data structures in R with the baton of
the purrr package!

#### Harmony in Chaos: Understanding List-Columns {#06a4 .graf .graf--h4 .graf-after--p name="06a4"}

Picture an orchestra where each musician brings their unique skillset
and instrument to create a harmonious symphony, striking the perfect
balance between order and chaos. This mirrors the concept of
list-columns in our data-orchestra. Each cell in a list-column can house
a list, rather than a single value as in traditional data frame columns.
This unique structure allows for a richer, more layered dataset, much
like the harmonious complexity of an orchestra's melody.

``` {#c829 .graf .graf--pre .graf-after--p .graf--preV2 code-block-mode="1" spellcheck="false" code-block-lang="perl"}
library(tidyverse)
# create a list-column
df <- tibble(
 x = 1:3,
 y = list(1:2, 1:3, 1:4)
)
print(df)

# A tibble: 3 × 2
x y 
<int> <list> 
 1 1 <int [2]>
 2 2 <int [3]>
 3 3 <int [4]>
```

With this code snippet, we've composed the first few bars of our
data-symphony, introducing a data frame with a list-column. In the 'y'
column, rather than seeing individual notes (or single data values), we
see miniature symphonies --- lists of values, all housed within a single
cell.

But remember, just as an orchestra is not composed in a day, so too does
understanding list-columns take time and practice. Each musician, each
instrument, adds to the overall melody, and each new note of knowledge
brings us closer to understanding the grand symphony of list-columns. It
may seem chaotic at first glance, but as we delve deeper into the layers
of this data structure, we'll uncover the order within the chaos, the
harmony within the cacophony.

It's crucial to acknowledge that complexity isn't a deterrent --- it's a
challenge that promises a greater depth of understanding. As we journey
through list-columns, remember that their complexity is their strength,
allowing for intricate compositions of data that bring new perspectives
to your analysis. So, let's embrace this unique element of our data
orchestra, wielding the baton of purrr with a renewed sense of purpose.

#### Conducting the Orchestra: Mapping Functions on List-Columns {#7822 .graf .graf--h4 .graf-after--p name="7822"}

Our exploration of the composition of list-columns would be incomplete
without the magic wand that every maestro needs --- mapping functions.
Mapping functions are to a conductor as bow is to a violinist, they help
to extract the desired notes, or in our case, data, from our
instruments.

Mapping functions are a cornerstone of purrr, allowing us to apply
functions to each element of a list or a list-column in a systematic
way. They can be seen as the conductor guiding the different sections of
the orchestra to play in unison, each producing their unique sound but
contributing to a harmonious melody.

In the case of list-columns, mapping functions can help us uncover and
manipulate the data hidden within these nested structures. Let's look at
an example with the `mtcars`{.markup--code .markup--p-code} dataset:

``` {#9f8b .graf .graf--pre .graf-after--p .graf--preV2 code-block-mode="1" spellcheck="false" code-block-lang="perl"}
library(dplyr)
library(purrr)
# Creating a list-column of data frames
mtcars_nested <- mtcars %>%
 split(.$cyl) 

# Applying a function to each data frame using map
mtcars_nested %>%
 map(~ summary(.))

$`4`
mpg             cyl         disp              hp              drat             wt       
Min.   :21.40   Min.   :4   Min.   : 71.10   Min.   : 52.00   Min.   :3.690   Min.   :1.513  
1st Qu.:22.80   1st Qu.:4   1st Qu.: 78.85   1st Qu.: 65.50   1st Qu.:3.810   1st Qu.:1.885  
Median :26.00   Median :4   Median :108.00   Median : 91.00   Median :4.080   Median :2.200  
Mean   :26.66   Mean   :4   Mean   :105.14   Mean   : 82.64   Mean   :4.071   Mean   :2.286  
3rd Qu.:30.40   3rd Qu.:4   3rd Qu.:120.65   3rd Qu.: 96.00   3rd Qu.:4.165   3rd Qu.:2.623  
Max.   :33.90   Max.   :4   Max.   :146.70   Max.   :113.00   Max.   :4.930   Max.   :3.190  
qsec             vs               am              gear            carb      
Min.   :16.70   Min.   :0.0000   Min.   :0.0000   Min.   :3.000   Min.   :1.000  
1st Qu.:18.56   1st Qu.:1.0000   1st Qu.:0.5000   1st Qu.:4.000   1st Qu.:1.000  
Median :18.90   Median :1.0000   Median :1.0000   Median :4.000   Median :2.000  
Mean   :19.14   Mean   :0.9091   Mean   :0.7273   Mean   :4.091   Mean   :1.545  
3rd Qu.:19.95   3rd Qu.:1.0000   3rd Qu.:1.0000   3rd Qu.:4.000   3rd Qu.:2.000  
Max.   :22.90   Max.   :1.0000   Max.   :1.0000   Max.   :5.000   Max.   :2.000  

$`6`
mpg             cyl         disp             hp             drat             wt       
Min.   :17.80   Min.   :6   Min.   :145.0   Min.   :105.0   Min.   :2.760   Min.   :2.620  
1st Qu.:18.65   1st Qu.:6   1st Qu.:160.0   1st Qu.:110.0   1st Qu.:3.350   1st Qu.:2.822  
Median :19.70   Median :6   Median :167.6   Median :110.0   Median :3.900   Median :3.215  
Mean   :19.74   Mean   :6   Mean   :183.3   Mean   :122.3   Mean   :3.586   Mean   :3.117  
3rd Qu.:21.00   3rd Qu.:6   3rd Qu.:196.3   3rd Qu.:123.0   3rd Qu.:3.910   3rd Qu.:3.440  
Max.   :21.40   Max.   :6   Max.   :258.0   Max.   :175.0   Max.   :3.920   Max.   :3.460  
qsec             vs               am              gear            carb      
Min.   :15.50   Min.   :0.0000   Min.   :0.0000   Min.   :3.000   Min.   :1.000  
1st Qu.:16.74   1st Qu.:0.0000   1st Qu.:0.0000   1st Qu.:3.500   1st Qu.:2.500  
Median :18.30   Median :1.0000   Median :0.0000   Median :4.000   Median :4.000  
Mean   :17.98   Mean   :0.5714   Mean   :0.4286   Mean   :3.857   Mean   :3.429  
3rd Qu.:19.17   3rd Qu.:1.0000   3rd Qu.:1.0000   3rd Qu.:4.000   3rd Qu.:4.000  
Max.   :20.22   Max.   :1.0000   Max.   :1.0000   Max.   :5.000   Max.   :6.000  

$`8`
mpg             cyl         disp             hp             drat             wt       
Min.   :10.40   Min.   :8   Min.   :275.8   Min.   :150.0   Min.   :2.760   Min.   :3.170  
1st Qu.:14.40   1st Qu.:8   1st Qu.:301.8   1st Qu.:176.2   1st Qu.:3.070   1st Qu.:3.533  
Median :15.20   Median :8   Median :350.5   Median :192.5   Median :3.115   Median :3.755  
Mean   :15.10   Mean   :8   Mean   :353.1   Mean   :209.2   Mean   :3.229   Mean   :3.999  
3rd Qu.:16.25   3rd Qu.:8   3rd Qu.:390.0   3rd Qu.:241.2   3rd Qu.:3.225   3rd Qu.:4.014  
Max.   :19.20   Max.   :8   Max.   :472.0   Max.   :335.0   Max.   :4.220   Max.   :5.424  
qsec             vs          am              gear            carb     
Min.   :14.50   Min.   :0   Min.   :0.0000   Min.   :3.000   Min.   :2.00  
1st Qu.:16.10   1st Qu.:0   1st Qu.:0.0000   1st Qu.:3.000   1st Qu.:2.25  
Median :17.18   Median :0   Median :0.0000   Median :3.000   Median :3.50  
Mean   :16.77   Mean   :0   Mean   :0.1429   Mean   :3.286   Mean   :3.50  
3rd Qu.:17.55   3rd Qu.:0   3rd Qu.:0.0000   3rd Qu.:3.000   3rd Qu.:4.00  
Max.   :18.00   Max.   :0   Max.   :1.0000   Max.   :5.000   Max.   :8.00  
```

In this example, we're applying the summary function to each data frame
in our list-column using the `map()`{.markup--code .markup--p-code}
function. The `~`{.markup--code .markup--p-code} is a shorthand for
defining a function in purrr, so `~ summary(.)`{.markup--code
.markup--p-code} is equivalent to `function(x) summary(x)`{.markup--code
.markup--p-code}. Like a conductor guiding the orchestra to play a
particular section of the score, the map function applies the summary
function to each nested data frame in our list-column.

This is just a glimpse of what mapping functions can do. They are
capable of orchestrating complex transformations and analyses on
list-columns and other list-like structures, making them indispensable
in our data analysis symphony.

#### Exploring the Soundscapes: Working with Nested Data Frames using purrr {#ed22 .graf .graf--h4 .graf-after--p name="ed22"}

Just as an explorer ventures into new lands, it's time for us to journey
through the intriguing landscapes of nested data frames using purrr.

Nested data frames can be considered as multilevel compositions in our
symphony, each bearing their unique tunes yet blending harmoniously to
create a beautiful melody. They add an additional layer of complexity by
nesting data frames within each row of another data frame. However, with
the potent power of purrr, this complexity can be tackled gracefully.

Let's take a look at how we can utilize purrr functions with nested data
frames:

``` {#3c58 .graf .graf--pre .graf-after--p .graf--preV2 code-block-mode="1" spellcheck="false" code-block-lang="bash"}
# Load the tidyr package
library(tidyr)

# Creating a nested data frame
mtcars_nested <- mtcars %>%
 group_by(cyl) %>%
 nest()

# Display the nested data frame
print(mtcars_nested)

# A tibble: 3 × 2
# Groups: cyl [3]
cyl data 
<dbl> <list> 
 6    <tibble [7 × 10]> 
 4    <tibble [11 × 10]>
 8    <tibble [14 × 10]>

# Applying a function to the nested data frame using map
mtcars_nested %>%
 mutate(mean_mpg = map_dbl(data, ~ mean(.$mpg)))

# A tibble: 3 × 3
# Groups: cyl [3]
cyl data mean_mpg
<dbl> <list>               <dbl>
 6    <tibble [7 × 10]>    19.7
 4    <tibble [11 × 10]>   26.7
 8    <tibble [14 × 10]>   15.1
```

In this example, we've created a nested data frame with
`nest()`{.markup--code .markup--p-code} function by nesting all columns
except `cyl`{.markup--code .markup--p-code} in `mtcars`{.markup--code
.markup--p-code}. Then, using `mutate()`{.markup--code .markup--p-code}
combined with `map_dbl()`{.markup--code .markup--p-code}, we computed
the mean of `mpg`{.markup--code .markup--p-code} for each nested data
frame.

You can imagine this as focusing on each individual section of the
orchestra, understanding their specific rhythm, and then integrating
that knowledge into the entire symphony.

The ability to traverse these nested data frames opens up new
possibilities for data analysis, enabling us to uncover deeper insights
within our data. Like the various sections of the orchestra uniting to
create a harmonious performance, the different layers of a nested data
frame can be collectively leveraged to tell a comprehensive data story.

With the power of purrr at our fingertips, we are well-equipped to
conduct our data orchestra through these complex soundscapes.

#### Symphony Rehearsals: Iterating over List-Columns and Nested Data Frames {#0d46 .graf .graf--h4 .graf-after--p name="0d46"}

You've tuned your instruments, studied the sheet music, and the
conductor has just given the downbeat. But how do you make your
orchestra play in unison? The answer lies in iterating over these
list-columns and nested data frames using purrr.

Consider a situation where you need to perform multiple operations on
different columns in each nested data frame. Imagine each player in the
orchestra playing their own instrument, but in harmony with the whole
ensemble. That's where `purrr`{.markup--code .markup--p-code}\'s iterate
functions like `map()`{.markup--code .markup--p-code},
`map2()`{.markup--code .markup--p-code}, and `pmap()`{.markup--code
.markup--p-code} shine.

For instance, let's compute the mean and standard deviation of
`mpg`{.markup--code .markup--p-code} within each `cyl`{.markup--code
.markup--p-code} group:

``` {#c2f7 .graf .graf--pre .graf-after--p .graf--preV2 code-block-mode="1" spellcheck="false" code-block-lang="xml"}
mtcars_nested %>%
 mutate(mean_mpg = map_dbl(data, ~ mean(.$mpg)),
 sd_mpg = map_dbl(data, ~ sd(.$mpg)))

# A tibble: 3 × 4
# Groups:   cyl [3]
cyl     data                  mean_mpg  sd_mpg
<dbl>   <list>                <dbl>     <dbl>
6       <tibble [7 × 10]>      19.7     1.45
4       <tibble [11 × 10]>     26.7     4.51
8       <tibble [14 × 10]>     15.1     2.56
```

Here, `map_dbl()`{.markup--code .markup--p-code} elegantly steps in,
repeating the operations for each nested data frame (or list-item in the
`data`{.markup--code .markup--p-code} column), and returns a double
vector. The result is an augmented data frame where the mean and
standard deviation of `mpg`{.markup--code .markup--p-code} for each
`cyl`{.markup--code .markup--p-code} group have been calculated and
added as new columns.

This ability to iterate over list-columns and nested data frames is akin
to a conductor ensuring that each instrument plays its part at the right
time, contributing to the harmony of the whole performance. The
resulting music is as beautiful as our tidily handled complex data
structure.

But remember, each piece of music has its tricky passages and potential
pitfalls. In our next section, we will explore some of these challenges
and strategies to overcome them in the context of complex data
structures.

#### Cacophonies and Solutions: Dealing with Complex Structures {#4d7e .graf .graf--h4 .graf-after--p name="4d7e"}

Any musician can tell you that perfect harmony is a combination of
practice and overcoming hurdles, and our journey with complex data
structures in R is no different. With list-columns and nested data
frames, we're weaving intricate musical phrases and occasionally,
cacophonies will emerge.

One common issue you might encounter with these structures is their
resistance to the usual data frame operations. For instance, if you try
to use `dplyr::filter()`{.markup--code .markup--p-code} or
`dplyr::select()`{.markup--code .markup--p-code} directly on a nested
data frame, you\'ll run into problems.

Consider this:

``` {#7775 .graf .graf--pre .graf-after--p .graf--preV2 code-block-mode="1" spellcheck="false" code-block-lang="typescript"}
mtcars_nested %>%
  filter(mean_mpg > 20)

Error in `filter()`:
ℹ In argument: `mean_mpg > 20`.
ℹ In group 1: `cyl = 4`.
Caused by error:
! object 'mean_mpg' not found
```

If you run this, R will throw an error because it doesn't know how to
compare a list-column to a single number. It's like trying to compare
the volume of a whole orchestra to a single violin --- it doesn't quite
work.

In this situation, you'd want to un-nest the data, perform the
filtering, and then re-nest if necessary. Alternatively, you can use the
`purrr::map()`{.markup--code .markup--p-code} function to apply the
filter within each list-item of the list-column. It\'s like adjusting
the sheet music for each individual musician.

``` {#2919 .graf .graf--pre .graf-after--p .graf--preV2 code-block-mode="1" spellcheck="false" code-block-lang="xml"}
mtcars_nested %>%
 mutate(data = map(data, ~ filter(.x, mpg > 20)))

# A tibble: 1 × 4
# Groups:   cyl [1]
    cyl data               mean_mpg sd_mpg
  <dbl> <list>                <dbl>  <dbl>
      4 <tibble [11 × 10]>     26.7   4.51
```

The above code will return the rows in each nested data frame where
`mpg`{.markup--code .markup--p-code} is greater than 20.

Remember, the key to dealing with these complex structures is to think
of them as collections of smaller pieces that you can manipulate
independently. Just as a symphony is comprised of individual notes that
together create a harmonious piece, your data structure is a collection
of components that can be handled one at a time. With practice, your
understanding of these structures will be music to your ears!
:::
::::
::::::

:::::: {#f2c7 .section .section .section--body .section--last}
::: section-divider

------------------------------------------------------------------------
:::

:::: section-content
::: {.section-inner .sectionLayout--insetColumn}
In this performance, we've attuned ourselves to the harmonious rhythms
of list-columns and nested data frames, conducting complex structures in
our R orchestration. We've demonstrated how the purrr package and its
various functions, like our virtuoso violinists, are instrumental in
navigating the symphony of nested data structures.

In many ways, working with list-columns and nested data frames is like
directing an orchestra. Each musician has a specific part to play, but
they all contribute to the overall melody. Just as each instrument in an
orchestra adds depth and richness to the music, each element in a
list-column or nested data frame adds complexity and granularity to our
data.

But, as with any musical masterpiece, it requires practice to perfect.
By understanding these structures and how to manipulate them, we've
acquired an important skill in data science. The ability to manage
complex data structures can open up new possibilities for your data
analysis, allowing you to work more efficiently and handle more
intricate datasets.

Continue to practice and explore these concepts. Every new dataset is a
fresh sheet of music waiting for your interpretation. Remember that the
more comfortable you are with the tools at your disposal, the more
effectively you can turn your data dissonance into a harmonious data
symphony. Let's continue to make beautiful music together with R and
purrr!
:::
::::
::::::
:::::::::::

By [Numbers around us](https://medium.com/@numbersaroundus){.p-author
.h-card} on [May 28, 2023](https://medium.com/p/728e96759af3).

[Canonical
link](https://medium.com/@numbersaroundus/symphony-of-structures-a-journey-through-list-columns-and-nested-data-frames-with-purrr-728e96759af3){.p-canonical}

Exported from [Medium](https://medium.com) on December 19, 2024.
