{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Getting Granular: How Tableau and Power BI Handle Level of Detail\"\n",
        "author: \"Numbers around us\"\n",
        "date: \"2025-05-04\"\n",
        "format: html\n",
        "---\n",
        "\n",
        "\n",
        "![](images/Getting%20Granular.png)\n",
        "\n",
        "# **The Hidden Complexity of Aggregation**\n",
        "\n",
        "At first glance, most BI tools make working with data feel effortless:\\\n",
        "Just drag a field into a chart, pick a measure, and boom — a sum, an average, a count.\n",
        "\n",
        "But this ease masks a subtle complexity:\n",
        "\n",
        "> **What if you need a metric that ignores the current chart granularity?**\\\n",
        "> **What if you want to summarize per customer but display per segment?**\\\n",
        "> **What if your filter affects one metric but not another?**\n",
        "\n",
        "That’s where **Level of Detail** (LOD) comes in — and where different tools offer very different solutions.\n",
        "\n",
        "In **Tableau**, you’ll reach for LOD expressions like:\n",
        "\n",
        "\n",
        "``` {tableau}\n",
        "{FIXED [Customer ID] : SUM(Sales)}\n",
        "```\n",
        "\n",
        "\n",
        "Or even:\n",
        "\n",
        "``` tableau\n",
        "{FIXED : COUNTD([Customer ID])}\n",
        "```\n",
        "\n",
        "…to get a constant or a sub-grain result that’s independent of your chart’s current breakdown.\n",
        "\n",
        "In **Power BI**, the same idea involves `CALCULATE()` and friends:\n",
        "\n",
        "\n",
        "``` {dax}\n",
        "CALCULATE(SUM(Sales), REMOVEFILTERS(Customer))\n",
        "```\n",
        "\n",
        "\n",
        "Or even:\n",
        "\n",
        "``` dax\n",
        "CALCULATE(DISTINCTCOUNT(Customer[ID]), REMOVEFILTERS())\n",
        "```\n",
        "\n",
        "Both tools allow you to **break out of the default aggregation logic**, but the way they handle it is rooted in very different models:\n",
        "\n",
        "-   Tableau thinks in terms of **viz grain** and **data scope**\n",
        "\n",
        "-   Power BI thinks in terms of **filter context** and **evaluation order**\n",
        "\n",
        "This article explores how these tools let you:\n",
        "\n",
        "-   Calculate **metrics at different levels** than the visible one\n",
        "\n",
        "-   Create **stable denominators** for % of total\n",
        "\n",
        "-   Handle **filters that affect one metric but not another**\n",
        "\n",
        "-   Think more clearly about **what granularity your calculation actually needs**\n",
        "\n",
        "Because once you go beyond drag-and-drop…\n",
        "\n",
        "> You’re not just visualizing the data — you’re shaping the *logic* behind the numbers.\n",
        "\n",
        "# **The Problem: One Chart, Two Granularities**\n",
        "\n",
        "BI tools love to aggregate. Drag a numeric field into a chart, and it happily sums, counts, or averages — usually at the level defined by your visual:\n",
        "\n",
        "> **\"Sales by Region\"** means Tableau or Power BI groups your sales records by region, then aggregates them.\n",
        "\n",
        "This works beautifully… until it doesn’t.\n",
        "\n",
        "### 🔍 Real-World Problems That Break the Default Grain\n",
        "\n",
        "Let’s say you want to show:\n",
        "\n",
        "-   **% of Total Sales per Category** — but the total should be **overall**, not filtered by Region\n",
        "\n",
        "-   **Average Sales per Customer** — even though you’re visualizing by Product Sub-Category\n",
        "\n",
        "-   **Top 1 Product per Region** — which requires aggregating sales, **then slicing** by region\n",
        "\n",
        "-   **Customer Count per Segment**, but with filters that **don’t apply** to that metric\n",
        "\n",
        "These are **common analytical questions** — and they all require a **different level of detail** than the current view.\n",
        "\n",
        "### ⚠️ Why This Trips People Up\n",
        "\n",
        "By default:\n",
        "\n",
        "-   **Tableau** calculates at the **visual level of detail (vizLOD)**\n",
        "\n",
        "-   **Power BI** evaluates filters based on **visual context and slicers**\n",
        "\n",
        "Which means:\n",
        "\n",
        "-   You often get a result, but **not the one you intended**.\n",
        "\n",
        "-   Worse: the chart looks fine — until someone asks:\n",
        "\n",
        "    > “Wait… why isn’t that total matching what I expected?”\n",
        "\n",
        "### 🎯 The Core Problem:\n",
        "\n",
        "> **You want to display data at one level… but calculate it at another.**\n",
        "\n",
        "And that’s where tools diverge in how they handle **explicit granularity control**.\n",
        "\n",
        "In the next sections, we’ll look at how Tableau uses **LOD expressions** and **context filters**, and how Power BI uses **DAX filter functions** to give you that control.\n",
        "\n",
        "# **Tableau’s Approach — LOD Expressions and Context Filters**\n",
        "\n",
        "In Tableau, the default behavior is to **aggregate at the level of the visualization**.\\\n",
        "So if you drag `[Sales]` into a view broken down by `[Category]`, Tableau will return `SUM(Sales)` for each category — simple and automatic.\n",
        "\n",
        "But what if you want to:\n",
        "\n",
        "-   Count unique customers **regardless of the view’s granularity**?\n",
        "\n",
        "-   Calculate sales **per customer**, then average **per region**?\n",
        "\n",
        "-   Compare a product’s sales **to the total across all products**, even when filtering?\n",
        "\n",
        "That’s where **Level of Detail (LOD) Expressions** come in.\n",
        "\n",
        "### 🔹 The LOD Syntax\n",
        "\n",
        "LOD expressions allow you to **override the default level of detail**.\n",
        "\n",
        "``` tableau\n",
        "{FIXED [Dimension(s)] : AGG([Measure])}\n",
        "{INCLUDE [Dimension(s)] : AGG([Measure])}\n",
        "{EXCLUDE [Dimension(s)] : AGG([Measure])}\n",
        "```\n",
        "\n",
        "Let’s walk through each.\n",
        "\n",
        "### ✅ `{FIXED}` — Lock to a Specific Level\n",
        "\n",
        "This expression **removes the influence of the view’s granularity** and uses only the dimensions you specify.\n",
        "\n",
        "``` tableau\n",
        "{FIXED [Customer Segment] : COUNTD([Customer ID])}\n",
        "```\n",
        "\n",
        "This counts **unique customers per segment**, even if your view is showing something else — like products or sub-categories.\n",
        "\n",
        "You can also use `{FIXED : ...}` with **no dimension**, which gives you a **global total**:\n",
        "\n",
        "``` tableau\n",
        "{FIXED : COUNTD([Customer ID])}\n",
        "```\n",
        "\n",
        "Use this when you want to:\n",
        "\n",
        "-   Create a constant denominator for % of total\n",
        "\n",
        "-   Create a reference value (e.g., max profit overall)\n",
        "\n",
        "### ✅ `{INCLUDE}` — Add Dimensions Temporarily\n",
        "\n",
        "This is like telling Tableau:\n",
        "\n",
        "> “Break this down further than the view does — then aggregate back up.”\n",
        "\n",
        "Example:\n",
        "\n",
        "``` tableau\n",
        "{INCLUDE [Product Name] : AVG([Sales])}\n",
        "```\n",
        "\n",
        "If your view is showing `[Region]`, this will calculate the **average sales per product**, then **average those within each region**.\n",
        "\n",
        "Use when:\n",
        "\n",
        "-   You want to bring in row-level granularity temporarily\n",
        "\n",
        "-   You’re working on ratio or per-item metrics\n",
        "\n",
        "### ✅ `{EXCLUDE}` — Remove Dimensions from the View\n",
        "\n",
        "The opposite of INCLUDE. You’re saying:\n",
        "\n",
        "> “I know the view is grouped by X and Y — but calculate as if it was just by X.”\n",
        "\n",
        "Example:\n",
        "\n",
        "``` tableau\n",
        "{EXCLUDE [Region] : SUM([Sales])}\n",
        "```\n",
        "\n",
        "This removes Region from the calculation, even if it’s present in the visual — useful for:\n",
        "\n",
        "-   Baselines\n",
        "\n",
        "-   Reference lines\n",
        "\n",
        "-   High-level metrics in detailed views\n",
        "\n",
        "### ⚠️ LOD Expression Gotchas\n",
        "\n",
        "-   **Filters can interfere** with LODs — which leads us to **Context Filters**\n",
        "\n",
        "-   `{FIXED}` expressions are evaluated **before most filters**\n",
        "\n",
        "-   If you want a filter to apply **before** the LOD expression, it must be set as a **Context Filter**\n",
        "\n",
        "### 🔸 Context Filters\n",
        "\n",
        "When you want a filter (like `[Order Date]`) to affect a `{FIXED}` expression, right-click it and choose **“Add to Context”**. This changes the filter's evaluation order so it’s applied **before the FIXED calculation runs**.\n",
        "\n",
        "If you don’t do this, your numbers may seem “wrong” — when in fact, they’re just not including your filter at the right time.\n",
        "\n",
        "### 🧠 Summary\n",
        "\n",
        "| Use Case                       | Expression Type                          |\n",
        "|-------------------------------|-----------------------------------------|\n",
        "| Count customers per region     | `{FIXED [Region] : COUNTD(Customer ID)}` |\n",
        "| Compare product sales to total | `{FIXED : SUM(Sales)}`                   |\n",
        "| Avg sales per item in view     | `{INCLUDE [Product Name] : AVG(Sales)}`  |\n",
        "| Ignore one dimension           | `{EXCLUDE [Region] : SUM(Sales)}`        |\n",
        "\n",
        "### 🔸 A Real-World Ratio: Most of the Time, It’s FIXED\n",
        "\n",
        "If you work with Tableau regularly, you’ll notice a pattern:\n",
        "\n",
        "> **Roughly 80% of the time, what you need is a `{FIXED}` expression.**\n",
        "\n",
        "-   You’re locking a metric to a specific business grouping (e.g., customer, region, segment)\n",
        "\n",
        "-   You want to isolate the calculation from the view's grain\n",
        "\n",
        "-   You need something stable and reusable across charts\n",
        "\n",
        "`{INCLUDE}` and `{EXCLUDE}` have their place — especially for row-level tricks or nested LOD logic —\\\n",
        "but in most use cases, **FIXED gives you the control and predictability you're after.**\n",
        "\n",
        "This doesn’t mean you should avoid the other types — just that understanding FIXED deeply will solve **most real-world LOD challenges**.\n",
        "\n",
        "# **Power BI’s Approach — CALCULATE and Context Control**\n",
        "\n",
        "While Tableau gives you explicit keywords to manipulate granularity, **Power BI** uses a different strategy:\n",
        "\n",
        "> It lets you control the **filter context** applied to any calculation — dynamically, precisely, and programmatically.\n",
        "\n",
        "At the core of this logic is DAX’s most important function:\n",
        "\n",
        "``` dax\n",
        "CALCULATE(<expression>, <filter1>, <filter2>, ...)\n",
        "```\n",
        "\n",
        "### 🧠 What CALCULATE Does\n",
        "\n",
        "> **CALCULATE** evaluates an expression in a **modified filter context**.\n",
        "\n",
        "This means:\n",
        "\n",
        "-   You can **change what filters apply**\n",
        "\n",
        "-   You can **remove**, **override**, or **narrow** filters from visuals, slicers, or page filters\n",
        "\n",
        "-   You’re not controlling “levels of detail” per se — you’re controlling the **filter logic that defines granularity**\n",
        "\n",
        "### ✅ Common Filter Modifiers in DAX\n",
        "\n",
        "Let’s look at the key functions you’ll use with `CALCULATE()` to handle different levels of context:\n",
        "\n",
        "| DAX Function      | What It Does                                         |\n",
        "|-------------------|------------------------------------------------------|\n",
        "| `REMOVEFILTERS()` | Ignores filters from visuals/slicers                 |\n",
        "| `ALL()`           | Removes all filters — useful for total / denominator |\n",
        "| `ALLEXCEPT()`     | Keeps only specified filters, removes others         |\n",
        "| `KEEPFILTERS()`   | Applies filters without replacing existing ones      |\n",
        "| `FILTER()`        | Builds custom row filters inside CALCULATE           |\n",
        "\n",
        "### 🔍 Examples\n",
        "\n",
        "#### 🔹 Global unique count of customers (like `{FIXED : COUNTD(...)}` in Tableau):\n",
        "\n",
        "``` dax\n",
        "CustomerCountGlobal = CALCULATE(DISTINCTCOUNT('Customers'[CustomerID]), REMOVEFILTERS())\n",
        "```\n",
        "\n",
        "🔹 Count customers per segment:\n",
        "\n",
        "``` dax\n",
        "CustomerPerSegment = CALCULATE(DISTINCTCOUNT('Customers'[CustomerID]))\n",
        "```\n",
        "\n",
        "🔹 Keep only one filter dimension (like Tableau’s `{FIXED [Segment] : ...}`):\n",
        "\n",
        "``` dax\n",
        "CustomerPerSegmentOnly = CALCULATE(\n",
        "  DISTINCTCOUNT('Customers'[CustomerID]),\n",
        "  ALLEXCEPT('Customers', 'Customers'[Segment])\n",
        ")\n",
        "```\n",
        "\n",
        "This says: “Remove all filters except Segment” — even if the visual also includes Region or Product.\\\n",
        "\\\n",
        "⚠️ Things to Watch For\n",
        "\n",
        "-   DAX has **row context** and **filter context** — and they’re evaluated differently. This trips people up fast.\n",
        "\n",
        "-   You must **explicitly control context** for complex calculations. There is no “LOD” keyword — it’s all logic.\n",
        "\n",
        "-   It’s easy to make the formula work, but **hard to explain why** if you’re not careful with variable naming and structuring.\n",
        "\n",
        "### ✍️ Practical Patterns\n",
        "\n",
        "| Use Case | Tableau | Power BI |\n",
        "|------------------------|------------------------|------------------------|\n",
        "| Global % of Total | `{FIXED : SUM(Sales)}` | `CALCULATE(SUM(Sales), REMOVEFILTERS())` |\n",
        "| Segment-level count | `{FIXED [Segment] : COUNTD(ID)}` | `CALCULATE(DISTINCTCOUNT(ID), ALLEXCEPT(...))` |\n",
        "| Top N inside group | FIXED with rank filter | `RANKX` + `CALCULATE(...)` per group |\n",
        "| Metric ignoring a slicer | FIXED LOD + context filter | `REMOVEFILTERS(SlicerTable[Field])` |\n",
        "\n",
        "### 🧠 Key Takeaway for Power BI Users\n",
        "\n",
        "> You’re not thinking in terms of “level of detail” — you’re thinking in **filter logic**.\n",
        "\n",
        "Power BI doesn’t show you what level it’s summarizing at — it just responds to whatever filters (visual, page, slicer) are in play.\\\n",
        "So **your job is to override those filters** when needed.\n",
        "\n",
        "# Final Thoughts & Takeaways\n",
        "\n",
        "When we talk about “level of detail,” we’re really talking about **control**.\n",
        "\n",
        "Most of the time, BI tools do a good job guessing how you want to aggregate your data. But when you start asking more specific, more meaningful questions — **\"How many customers are we serving regardless of category?\"** or **\"What was the average per transaction, not per visual group?\"** — you need to take control.\n",
        "\n",
        "And that’s where things diverge.\n",
        "\n",
        "### 🔷 Tableau’s Approach\n",
        "\n",
        "-   Tableau gives you **straightforward LOD expressions** (`FIXED`, `INCLUDE`, `EXCLUDE`) that are **explicit, readable, and scoped.**\n",
        "\n",
        "-   You say what you want to include or ignore — and Tableau does it.\n",
        "\n",
        "-   In most real-world scenarios, **`FIXED` covers 80% of use cases**.\n",
        "\n",
        "Its strength is clarity — but you do need to understand **context filters** and **evaluation order** when things get tricky.\n",
        "\n",
        "### 🔶 Power BI’s Approach\n",
        "\n",
        "-   Power BI uses **DAX functions like `CALCULATE()`**, paired with filter functions like `ALL()`, `REMOVEFILTERS()`, and `ALLEXCEPT()`.\n",
        "\n",
        "-   Instead of writing one-off LOD logic, you **modify the filter context** in which your measure is evaluated.\n",
        "\n",
        "-   It’s **more flexible**, but also more verbose and less intuitive at first.\n",
        "\n",
        "Its strength is power — but you must deeply understand how **row context and filter context** interact.\n",
        "\n",
        "### 🧠 What They Have in Common\n",
        "\n",
        "-   Both tools make **assumptions** about aggregation unless you tell them otherwise.\n",
        "\n",
        "-   Both allow you to calculate at **different levels** than what’s shown in the visual.\n",
        "\n",
        "-   Both reward you for thinking clearly about **intent** — what is the grain of your calculation?\n",
        "\n",
        "### ✍️ Final Tip\n",
        "\n",
        "> Don’t just ask “what do I want to show?”\\\n",
        "> Ask: **“At what level should this number be calculated?”**\n",
        "\n",
        "That shift in thinking separates good dashboard builders from great analysts."
      ],
      "id": "0a758623"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "C:\\Users\\kgryc\\anaconda3\\share\\jupyter\\kernels\\python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}