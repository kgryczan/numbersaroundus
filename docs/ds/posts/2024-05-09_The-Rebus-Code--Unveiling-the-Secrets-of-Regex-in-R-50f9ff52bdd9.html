<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.37">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Numbers around us">
<meta name="dcterms.date" content="2024-05-09">

<title>The Rebus Code: Unveiling the Secrets of Regex in R – Numbers Around Us</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-cb71375167fd9ce754afb6fa31d3f44e.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark-1a65b4115a9519dac2c2f4ba2497ca08.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Numbers Around Us</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../challenges/index.html"> 
<span class="menu-text">Challenges</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../bi/index.html"> 
<span class="menu-text">Business Intelligence</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../ds/index.html"> 
<span class="menu-text">Data Science</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../dp/index.html"> 
<span class="menu-text">Date Philosophy</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
    <a href="https://github.com" title="Github" class="quarto-navigation-tool px-1" aria-label="Github"><i class="bi bi-github"></i></a>
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">The Rebus Code: Unveiling the Secrets of Regex in R</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Numbers around us </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">May 9, 2024</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="the-rebus-code-unveiling-the-secrets-of-regex-in-r" class="level3">
<h3 class="anchored" data-anchor-id="the-rebus-code-unveiling-the-secrets-of-regex-in-r">The Rebus Code: Unveiling the Secrets of Regex in R</h3>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/rebus.jpg" class="img-fluid figure-img"></p>
<figcaption>Image</figcaption>
</figure>
</div>
<p>In the intricate world of data analysis, the task of text pattern recognition and extraction is akin to unlocking a secret cipher hidden within ancient manuscripts. This is the realm of regular expressions (regex), a powerful yet often underappreciated tool in the data scientist’s toolkit. Much like the cryptex from Dan Brown’s “The Da Vinci Code,” which holds the key to unraveling historical and cryptic puzzles, regular expressions unlock the patterns embedded in strings of text data.</p>
<p>However, the power of regex comes at a cost — its syntax is notoriously complex and can be as enigmatic as the riddles solved by Robert Langdon in his thrilling adventures. For those not versed in its arcane symbols, crafting regex patterns can feel like deciphering a code without a Rosetta Stone. This is where the <code>rebus</code> package in R provides a lifeline. It simplifies the creation of regex expressions, transforming them from a cryptic sequence of characters into a readable and manageable code, akin to translating a hidden message in an old relic.</p>
<p>In this tutorial, we embark on a journey akin to that of Langdon’s through Paris and London, but instead of ancient symbols hidden in art, we’ll navigate through the complexities of text data. We will explore the fundamental principles of regex that form the backbone of text manipulation tasks. From basic pattern matching to crafting intricate regex expressions with the <code>rebus</code> package, this guide will illuminate the path towards mastering regex in R, making the process as engaging as uncovering a secret passage in an ancient temple.</p>
<p>Just as Langdon used his knowledge of symbolism to solve mysteries, we will use <code>rebus</code> to demystify regex in R, making this powerful tool accessible and practical for everyday data tasks. Whether you’re a seasoned data scientist or a novice in the field, understanding how to effectively use regex is like discovering a hidden map that leads to buried treasure, providing you with the insights necessary to make informed decisions based on your data.</p>
<p>With our thematic setting now established, let us delve deeper into the world of regular expressions and reveal how the <code>rebus</code> package can transform your approach to data analysis, turning a daunting task into an intriguing puzzle-solving adventure.</p>
</section>
<section id="unveiling-the-symbols" class="level3">
<h3 class="anchored" data-anchor-id="unveiling-the-symbols">Unveiling the Symbols</h3>
<p>Regular expressions operate through special characters that, when combined, form patterns capable of matching and extracting text with incredible precision. Here are a few fundamental symbols to understand:</p>
<ul>
<li><strong>Dot (<code>.</code>)</strong>: Like the omnipresent eye in a Da Vinci painting, the dot matches any single character, except newline characters. It sees all but the end of a line.</li>
<li><strong>Asterisk (<code>*</code>)</strong>: Mirroring the endless loops in a Fibonacci spiral, the asterisk matches the preceding element zero or more times, extending its reach across the string.</li>
<li><strong>Plus (<code>+</code>)</strong>: This symbol requires the preceding element to appear at least once, much like insisting on the presence of a key motif in an artwork.</li>
<li><strong>Question Mark (<code>?</code>)</strong>: It makes the preceding element optional, introducing ambiguity into the pattern, akin to an unclear symbol whose meaning might vary.</li>
<li><strong>Caret (<code>^</code>)</strong>: Matching the start of a string, the caret sets the stage much like the opening scene in a historical mystery.</li>
<li><strong>Dollar Sign (<code>$</code>)</strong>: This symbol matches the end of a string, providing closure and ensuring that the pattern adheres strictly to the end of the text.</li>
</ul>
</section>
<section id="example-simple-patterns-in-action" class="level3">
<h3 class="anchored" data-anchor-id="example-simple-patterns-in-action">Example: Simple Patterns in Action</h3>
<p>Using the <code>stringr</code> library enhances readability and flexibility in handling regular expressions. Let’s apply this to find specific patterns:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(stringr)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>text_vector <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"Secrets are hidden within."</span>, <span class="st">"The key is under the mat."</span>, </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>                 <span class="st">"Look inside, find the truth."</span>, <span class="st">"Bridge is damaged by the storm"</span>)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="fu">str_detect</span>(text_vector, <span class="st">"</span><span class="sc">\\</span><span class="st">bis</span><span class="sc">\\</span><span class="st">b"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This code chunk checks if the word “is” is anywhere in the given sentence.</p>
</section>
<section id="crafting-your-first-regex" class="level3">
<h3 class="anchored" data-anchor-id="crafting-your-first-regex">Crafting Your First Regex</h3>
<p>To identify any word that ends with ‘ed’, signaling past actions, akin to uncovering traces of events long gone:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Match words ending with 'ed'</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="fu">str_extract</span>(text_vector, <span class="st">"</span><span class="sc">\\</span><span class="st">b[A-Za-z]+ed</span><span class="sc">\\</span><span class="st">b"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This expression uses <code>\\b</code> to ensure that ‘ed’ is at the end of the word, capturing complete words and not fragments—critical when every detail in a coded message matters.</p>
</section>
<section id="deciphering-a-complex-regex" class="level3">
<h3 class="anchored" data-anchor-id="deciphering-a-complex-regex">Deciphering a Complex Regex</h3>
<p>Let’s consider a more intricate regex pattern:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>date_pattern <span class="ot">&lt;-</span> <span class="st">"</span><span class="sc">\\</span><span class="st">b(0[1-9]|[12][0-9]|3[01])[- /.](0[1-9]|1[012])[- /.](19|20)</span><span class="sc">\\</span><span class="st">d</span><span class="sc">\\</span><span class="st">d</span><span class="sc">\\</span><span class="st">b"</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="co"># first check if pattern is present</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="fu">str_detect</span>(<span class="st">"She was born on 12/08/1993, and he on 04/07/1989."</span>, date_pattern)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="co"># second extract the pattern</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="fu">str_extract_all</span>(<span class="st">"She was born on 12/08/1993, and he on 04/07/1989."</span>, date_pattern)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This regex looks extremely unfriendly at first glance, resembling an arcane code more than a helpful tool. It uses capturing groups, ranges, and alternations to accurately match dates in a specific format. Here’s the breakdown:</p>
<ul>
<li><code>\b</code>: Word boundary, ensuring we match whole dates.</li>
<li><code>(0[1–9]|[12][0–9]|3[01])</code>: Matches days from 01 to 31.</li>
<li><code>[- /.]</code>: Matches separators which can be a dash, space, dot, or slash.</li>
<li><code>(0[1–9]|1[012])</code>: Matches months from 01 to 12.</li>
<li><code>(19|20)\d\d</code>: Matches years from 1900 to 2099.</li>
</ul>
<p>This example shows how raw regex can quickly become complex and hard to follow, much like a cryptic puzzle waiting to be solved. The rebus package can help simplify these expressions, making them more accessible and easier to manage.</p>
</section>
<section id="building-blocks-of-rebus" class="level3">
<h3 class="anchored" data-anchor-id="building-blocks-of-rebus">Building Blocks of Rebus</h3>
<p>Just as Robert Langdon in “The Da Vinci Code” used his knowledge of symbology to decode complex historical puzzles, the <code>rebus</code> package in R enables us to build regular expressions from understandable components, transforming arcane syntax into legible code. This approach not only simplifies regex creation but also enhances readability and maintenance, making regex patterns as approachable as reading a museum guidebook.</p>
</section>
<section id="assembling-the-codex" class="level3">
<h3 class="anchored" data-anchor-id="assembling-the-codex">Assembling the Codex</h3>
<p>Rebus operates on the principle of constructing regex patterns piece by piece using function calls, which represent different regex components. This method aligns with piecing together clues from a scattered array of symbols to form a coherent understanding. Here are some of the building blocks provided by rebus:</p>
<ul>
<li><code>digit()</code>: Matches any number, simplifying digit recognition.</li>
<li><code>or()</code>: Specifies a set of characters to match, allowing customization akin to selecting specific tools for a dig site.</li>
</ul>
</section>
<section id="example-email-pattern-construction-with-rebus" class="level3">
<h3 class="anchored" data-anchor-id="example-email-pattern-construction-with-rebus">Example: Email Pattern Construction with Rebus</h3>
<p>Crafting an email validation pattern with rebus is akin to assembling a puzzle where each piece must fit precisely:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(rebus)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Define the pattern for a standard email</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>email_pattern <span class="ot">&lt;-</span> START <span class="sc">%R%</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">one_or_more</span>(WRD) <span class="sc">%R%</span> <span class="st">"@"</span> <span class="sc">%R%</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">one_or_more</span>(WRD) <span class="sc">%R%</span> DOT <span class="sc">%R%</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">or</span>(<span class="st">"com"</span>, <span class="st">"org"</span>, <span class="st">"net"</span>)</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Use the pattern to find valid emails</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>sample_text <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"contact@example.com"</span>, <span class="st">"hello@world.net"</span>, <span class="st">"not-an-email"</span>)</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="fu">str_detect</span>(sample_text, email_pattern)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This pattern, built with rebus functions, makes it easy to understand at a glance which components form the email structure, demystifying the regex pattern much like Langdon revealing the secrets behind a hidden inscription.</p>
</section>
<section id="deciphering-complex-text-patterns-with-rebus" class="level3">
<h3 class="anchored" data-anchor-id="deciphering-complex-text-patterns-with-rebus">Deciphering Complex Text Patterns with Rebus</h3>
<p>Consider a more complicated scenario where you need to validate date formats within a text. Using basic regex might involve a lengthy and cryptic pattern, but with rebus, we can construct it step-by-step:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Define a pattern for dates in the format DD/MM/YYYY</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>date_pattern <span class="ot">&lt;-</span> </span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">digit</span>(<span class="dv">2</span>) <span class="sc">%R%</span> <span class="st">"/"</span> <span class="sc">%R%</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">digit</span>(<span class="dv">2</span>) <span class="sc">%R%</span> <span class="st">"/"</span> <span class="sc">%R%</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">digit</span>(<span class="dv">4</span>) </span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample text for pattern matching</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>dates_text <span class="ot">&lt;-</span> <span class="st">"Important dates are 01/01/2020 and 31/12/2020."</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="co"># First check if pattern can be found in text.</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="fu">str_detect</span>(dates_text, date_pattern)</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Then what it extracts.</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a><span class="fu">str_extract_all</span>(dates_text, date_pattern)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This example shows how rebus simplifies complex regex tasks, turning them into a series of logical steps, much like solving a riddle in an ancient tome.</p>
<p>But wait a minute… It is always a good idea to dig in documentation, and check out what can be found there.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>dmy_pattern <span class="ot">=</span> DMY</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="fu">str_detect</span>(dates_text, dmy_pattern)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="fu">str_extract_all</span>(dates_text, dmy_pattern)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="tips-for-crafting-expressions-with-rebus" class="level3">
<h3 class="anchored" data-anchor-id="tips-for-crafting-expressions-with-rebus">Tips for Crafting Expressions with Rebus</h3>
<p>While rebus makes it easier to create and understand regex patterns, there are tips to further enhance your mastery:</p>
<ol type="1">
<li><strong>Start Simple</strong>: Begin with basic components and gradually add complexity.</li>
<li><strong>Test Often</strong>: Use sample data to test and refine your patterns frequently.</li>
<li><strong>Comment Your Code</strong>: Annotate your rebus expressions to explain the purpose of each component, especially in complex patterns.</li>
</ol>
</section>
<section id="extracting-complex-medical-data-from-clinical-notes" class="level3">
<h3 class="anchored" data-anchor-id="extracting-complex-medical-data-from-clinical-notes">Extracting Complex Medical Data from Clinical Notes</h3>
<p>In the vein of a detective novel, akin to “The Da Vinci Code,” where each clue unravels a part of a larger mystery, this scenario involves deciphering clinical notes to extract specific medical information. This requires a keen understanding of the text’s structure and content, mirroring the precision needed to solve a cryptic puzzle left in an ancient artifact.</p>
</section>
<section id="setting-the-scene-medical-data-extraction-challenge" class="level3">
<h3 class="anchored" data-anchor-id="setting-the-scene-medical-data-extraction-challenge">Setting the Scene: Medical Data Extraction Challenge</h3>
<p>Clinical notes are packed with crucial medical details in a format that is often not standardized, making the extraction of specific information like medication prescriptions and patient diagnoses a complex task. Our goal is to develop regex patterns that can accurately identify and extract this information from varied text formats.</p>
</section>
<section id="step-by-step-pattern-construction-using-rebus" class="level3">
<h3 class="anchored" data-anchor-id="step-by-step-pattern-construction-using-rebus">Step-by-Step Pattern Construction Using Rebus</h3>
<section id="define-complex-patterns" class="level4">
<h4 class="anchored" data-anchor-id="define-complex-patterns">Define Complex Patterns:</h4>
<ul>
<li>Medications often mentioned with dosages and frequencies.</li>
<li>Diagnoses that may include medical terms and conditions.</li>
</ul>
<div class="sourceCode" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(rebus)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(stringr)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Pattern for medication prescriptions</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Example format: [Medication Name] [Dosage in mg] [Frequency]</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>medication_pattern <span class="ot">&lt;-</span> <span class="fu">one_or_more</span>(WRD) <span class="sc">%R%</span> SPACE <span class="sc">%R%</span> <span class="fu">one_or_more</span>(DGT) <span class="sc">%R%</span> <span class="st">"mg"</span> <span class="sc">%R%</span> SPACE <span class="sc">%R%</span> <span class="fu">one_or_more</span>(WRD)</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Pattern for diagnoses</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Example format: Diagnosed with [Condition]</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>diagnosis_pattern <span class="ot">&lt;-</span> <span class="st">"Diagnosed with "</span> <span class="sc">%R%</span> <span class="fu">one_or_more</span>(WRD <span class="sc">%R%</span> <span class="fu">optional</span>(SPACE <span class="sc">%R%</span> WRD))</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>clinical_notes <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"Patient was prescribed Metformin 500mg twice daily for type 2 diabetes."</span>,</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>                    <span class="st">"Diagnosed with Chronic Heart Failure and hypertension."</span>,</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>                    <span class="st">"Amlodipine 10mg once daily was recommended."</span>,</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>                    <span class="st">"Review scheduled without any new prescriptions."</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="sample-clinical-notes" class="level3">
<h3 class="anchored" data-anchor-id="sample-clinical-notes">Sample Clinical Notes:</h3>
<div class="sourceCode" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>clinical_notes <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"Patient was prescribed Metformin 500mg twice daily for type 2 diabetes."</span>,</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>                    <span class="st">"Diagnosed with Chronic Heart Failure and hypertension."</span>,</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>                    <span class="st">"Amlodipine 10mg once daily was recommended."</span>,</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>                    <span class="st">"Review scheduled without any new prescriptions."</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="extract-and-validate-medical-data" class="level3">
<h3 class="anchored" data-anchor-id="extract-and-validate-medical-data">Extract and Validate Medical Data:</h3>
<div class="sourceCode" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Extracting medication details</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>medication_details <span class="ot">&lt;-</span> <span class="fu">str_extract_all</span>(clinical_notes, medication_pattern)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Extracting diagnoses</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>diagnoses_found <span class="ot">&lt;-</span> <span class="fu">str_extract_all</span>(clinical_notes, diagnosis_pattern)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="example-advanced-code-walkthrough" class="level3">
<h3 class="anchored" data-anchor-id="example-advanced-code-walkthrough">Example: Advanced Code Walkthrough</h3>
<p>By running the above patterns against the clinical notes, we extract structured information about medications and diagnoses:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(medication_details)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>[[<span class="dv">1</span>]]</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>] <span class="st">"Metformin 500mg twice"</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>[[<span class="dv">2</span>]]</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="fu">character</span>(<span class="dv">0</span>)</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>[[<span class="dv">3</span>]]</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>] <span class="st">"Amlodipine 10mg once"</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>[[<span class="dv">4</span>]]</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a><span class="fu">character</span>(<span class="dv">0</span>)</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(diagnoses_found)</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>[[<span class="dv">1</span>]]</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a><span class="fu">character</span>(<span class="dv">0</span>)</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>[[<span class="dv">2</span>]]</span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>] <span class="st">"Diagnosed with Chronic Heart Failure and hypertension"</span></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>[[<span class="dv">3</span>]]</span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a><span class="fu">character</span>(<span class="dv">0</span>)</span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a>[[<span class="dv">4</span>]]</span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a><span class="fu">character</span>(<span class="dv">0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This code extracts arrays containing detailed medication prescriptions and diagnosed conditions from each note, if available.</p>
</section>
<section id="handling-edge-cases-and-variability" class="level3">
<h3 class="anchored" data-anchor-id="handling-edge-cases-and-variability">Handling Edge Cases and Variability</h3>
<p>Medical terms and prescriptions can vary greatly:</p>
<ul>
<li><strong>Expand Vocabulary in Rebus</strong>: Include variations and synonyms of medical conditions and medication names.</li>
<li><strong>Adjust for Complex Dosage Instructions</strong>: Medications might have dosages described in different units or intervals.</li>
</ul>
</section>
<section id="mastering-medical-data-extraction" class="level3">
<h3 class="anchored" data-anchor-id="mastering-medical-data-extraction">Mastering Medical Data Extraction</h3>
<p>Just as each puzzle piece in “The Da Vinci Code” led to deeper historical insights, each regex pattern crafted with <code>rebus</code> reveals vital medical information from clinical notes, enabling better patient management and data-driven decision-making in healthcare.</p>
</section>
<section id="mastering-regex-with-rebus-for-complex-data-extraction" class="level3">
<h3 class="anchored" data-anchor-id="mastering-regex-with-rebus-for-complex-data-extraction">Mastering Regex with Rebus for Complex Data Extraction</h3>
<p>Navigating through complex data with regex and the <code>rebus</code> package is akin to deciphering hidden codes and symbols in a Dan Brown novel. Just as Robert Langdon uses his knowledge of symbology to unravel mysteries in “The Da Vinci Code,” data scientists and analysts use regex patterns crafted with <code>rebus</code> to unlock the mysteries within their data sets. This guide has shown how <code>rebus</code> transforms an intimidating script into a manageable and understandable set of building blocks, enabling precise data extraction across various domains, from legal documents to medical records.</p>
</section>
<section id="final-thoughts-the-art-of-regex-crafting" class="level3">
<h3 class="anchored" data-anchor-id="final-thoughts-the-art-of-regex-crafting">Final Thoughts: The Art of Regex Crafting</h3>
<ol type="1">
<li><strong>Iterative Development:</strong> Like solving a cryptic puzzle, developing effective regex patterns often requires an iterative approach. Start with a basic pattern, test it, refine it based on the outcomes, and gradually incorporate complexity as needed.</li>
<li><strong>Comprehensive Testing:</strong> Ensure your regex patterns perform as expected across all possible scenarios. This includes testing with diverse data samples to cover all potential variations and edge cases, mirroring the meticulous verification of clues in a historical investigation.</li>
<li><strong>Documentation and Comments:</strong> Regex patterns, especially complex ones, can quickly become inscrutable. Document your patterns and use comments within your <code>rebus</code> expressions to explain their purpose and structure. This practice ensures that your code remains accessible not just to you but to others who may work on it later, much like leaving a detailed map for those who follow in your footsteps.</li>
<li><strong>Stay Updated:</strong> Just as new archaeological discoveries can change historical understandings, advancements in programming and new versions of packages like <code>rebus</code> can introduce more efficient ways to handle data. Keeping your skills and knowledge up to date is crucial.</li>
<li><strong>Share Knowledge</strong>: Just as scholars share their discoveries and insights, sharing your challenges and solutions in regex with the community can help others. Participate in forums, write blogs, or give talks on your regex strategies and how you’ve used <code>rebus</code> to solve complex data extraction problems.</li>
</ol>
</section>
<section id="strategies-for-employing-rebus-effectively" class="level3">
<h3 class="anchored" data-anchor-id="strategies-for-employing-rebus-effectively">Strategies for Employing <code>rebus</code> Effectively</h3>
<ul>
<li><strong>Utilize <code>rebus</code> Libraries:</strong> Leverage the full suite of <code>rebus</code> functionalities by familiarizing yourself with all its helper functions and modules. Each function is designed to simplify a specific aspect of regex pattern creation, which can drastically reduce the complexity of your code.</li>
<li><strong>Pattern Modularity</strong>: Build your regex patterns in modular chunks using <code>rebus</code>, similar to constructing a narrative or solving a multi-part puzzle. This approach not only simplifies the development and testing of regex patterns but also enhances readability and maintenance.</li>
<li><strong>Advanced Matching Techniques:</strong> For highly variable data, consider advanced regex features like lookaheads, lookbehinds, and conditional statements, which can be integrated into your <code>rebus</code> patterns. These features allow for more dynamic and flexible pattern matching, akin to adapting your hypothesis in light of new evidence.</li>
</ul>
</section>
<section id="epilogue-the-power-of-clarity-in-data-parsing" class="level3">
<h3 class="anchored" data-anchor-id="epilogue-the-power-of-clarity-in-data-parsing">Epilogue: The Power of Clarity in Data Parsing</h3>
<p>In conclusion, mastering <code>rebus</code> and regex is like becoming fluent in a secret language that opens up vast archives of data, ready to be explored and understood. This guide has equipped you with the tools to start this journey, providing the means to reveal the stories hidden within complex datasets, enhance analytical accuracy, and drive insightful decisions.</p>
<p>Just as every clue solved brings Langdon closer to the truth in “The Da Vinci Code,” each pattern you decipher with <code>rebus</code> brings you closer to mastering the art of data. The path is laid out before you—begin your adventure, solve the puzzles, and unlock the potential of your data with confidence.</p>
</section>
<section id="appendix-the-regex-rosetta-stone-a-comprehensive-reference-guide" class="level3">
<h3 class="anchored" data-anchor-id="appendix-the-regex-rosetta-stone-a-comprehensive-reference-guide">Appendix: The Regex Rosetta Stone — A Comprehensive Reference Guide</h3>
<p>This appendix is designed as a quick yet comprehensive reference guide to using the <code>rebus</code> package for crafting regex expressions in R. Here you will find a brief description of some of the most pivotal functions, character classes, ready-made patterns, and interesting trivia on less commonly used regex features.</p>
</section>
<section id="most-common-functions-in-rebus" class="level3">
<h3 class="anchored" data-anchor-id="most-common-functions-in-rebus">1. Most Common Functions in <code>rebus</code></h3>
<p>Let’s explore some of the essential <code>rebus</code> functions that you can use to construct regex patterns more intuitively:</p>
<ul>
<li><code>or()</code>: Combines multiple patterns and matches any of them. Useful for alternatives in a pattern.</li>
<li><code>exactly()</code>: Specifies that the preceding element should occur an exact number of times.</li>
<li><code>literal()</code>: Treats the following string as literal text, escaping any special regex characters.</li>
<li><code>optional()</code>: Indicates that the preceding element is optional, matching it zero or one time.</li>
<li><code>zero_or_more()</code>: Matches zero or more occurrences of the preceding element.</li>
<li><code>one_or_more()</code>: Matches one or more occurrences of the preceding element.</li>
<li><code>lookahead()</code>: Checks for a match ahead of the current position without consuming characters.</li>
<li><code>lookbehind()</code>: Asserts something to be true behind the current position in the text.</li>
<li><code>repeated()</code>: Matches a specified number of repetitions of the preceding element.</li>
<li><code>whole_word()</code>: Ensures that the pattern matches a complete word.</li>
</ul>
</section>
<section id="most-common-character-classes" class="level3">
<h3 class="anchored" data-anchor-id="most-common-character-classes">2. Most Common Character Classes</h3>
<p>Character classes simplify the specification of a set of characters to match:</p>
<ul>
<li><code>DGT</code> (Digit): Matches any digit, shorthand for <code>digit()</code>.</li>
<li><code>ALNUM</code> (Alphanumeric): Matches any alphanumeric character.</li>
<li><code>LOWER</code>: Matches any lowercase letter.</li>
<li><code>UPPER</code>: Matches any uppercase letter.</li>
<li><code>SPECIALS</code>: Matches any special characters typically found on a keyboard.</li>
<li><code>ROMAN</code>: Matches Roman numerals.</li>
<li><code>PUNCT</code> (Punctuation): Matches any punctuation character.</li>
<li><code>NOT_DGT</code> (Not Digit): Matches any character that is not a digit.</li>
<li><code>HEX_DIGIT</code> (Hexadecimal Digit): Matches hexadecimal digits (0-9, A-F).</li>
<li><code>KATAKANA</code>, <code>HIRAGANA</code>: Matches characters from the Japanese Katakana and Hiragana scripts.</li>
<li><code>HEBREW</code>, <code>CYRILLIC</code>, <code>ARABIC</code>: Matches characters from the Hebrew, Cyrillic, and Arabic scripts.</li>
</ul>
</section>
<section id="ready-patterns" class="level3">
<h3 class="anchored" data-anchor-id="ready-patterns">3. Ready Patterns</h3>
<p><code>rebus</code> also includes functions for common pattern templates:</p>
<ul>
<li><code>YMD</code>: Matches dates in Year-Month-Day format.</li>
<li><code>TIME</code>: Matches time in HH:MM:SS format.</li>
<li><code>AM_PM</code>: Matches time qualifiers AM or PM.</li>
<li><code>CURRENCY_SYMBOLS</code>: Matches common currency symbols.</li>
<li><code>HOUR12</code>: Matches hour in 12-hour format.</li>
</ul>
</section>
<section id="interesting-but-less-used-character-classes-trivia" class="level3">
<h3 class="anchored" data-anchor-id="interesting-but-less-used-character-classes-trivia">4. Interesting But Less Used Character Classes (Trivia)</h3>
<p>Explore some unique and less commonly used character classes:</p>
<ul>
<li><code>DOMINO_TILES</code>: Matches Unicode representations of domino tiles.</li>
<li><code>PLAYING_CARDS</code>: Matches Unicode characters representing playing cards.</li>
</ul>
<p>These unique character classes add a fun and often surprising depth to regex capabilities, allowing for creative data parsing and matching scenarios, much like uncovering an unexpected twist in a puzzle or story.</p>
<p>By familiarizing yourself with these tools, you can significantly enhance your ability to analyze and manipulate data effectively, transforming complex text into structured and insightful information. Keep this guide handy as a reference to navigate the vast landscape of regex with confidence and precision.</p>
</section>
<section id="final-tip" class="level3">
<h3 class="anchored" data-anchor-id="final-tip">Final Tip:</h3>
<p>If you haven’t already noted it, there is one small trick that will help you make step from using <code>rebus</code> to use “vanilla” regular expressions. When you place pattern in variable in your environment it is storing it as real RegExp, so if you would like to see it, and maybe use it directly in code, just print it to console.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Imagine that there is some official number that consists of following parts</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Date in format YYYYMMDD, then letter T, then time in format HHMMSS and indicator AM or PM</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Looks pretty simple, and indeed is using rebus</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>pattern <span class="ot">=</span> YMD <span class="sc">%R%</span> <span class="st">"T"</span> <span class="sc">%R%</span> HMS <span class="sc">%R%</span> AM_PM</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Now look to raw RegExp version.</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(pattern)</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="co"># [0-9]{1,4}[-/.:,\ ]?(?:0[1-9]|1[0-2])[-/.:,\ ]?(?:0[1-9]|[12][0-9]|3[01])T(?:[01][0-9]|2[0-3])[-/.:,\ ]?[0-5][0-9][-/.:,\ ]?(?:[0-5][0-9]|6[01])(?:am|AM|pm|PM)</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>valid <span class="ot">=</span>  <span class="st">"20180101T120000AM"</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a><span class="fu">str_detect</span>(valid, pattern)</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a><span class="co"># [1] TRUE</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = true;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p>For everybody, not to be fooled by numbers</p>
</div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>