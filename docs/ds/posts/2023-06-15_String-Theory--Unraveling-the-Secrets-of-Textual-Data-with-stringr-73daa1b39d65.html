<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.37">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Numbers around us">
<meta name="dcterms.date" content="2023-06-15">

<title>String Theory: Unraveling the Secrets of Textual Data with stringr – Numbers Around Us</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-cb71375167fd9ce754afb6fa31d3f44e.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark-1a65b4115a9519dac2c2f4ba2497ca08.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Numbers Around Us</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../last-articles.html"> 
<span class="menu-text">Newest articles</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../challenges/index.html"> 
<span class="menu-text">Challenges</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../bi/index.html"> 
<span class="menu-text">Business Intelligence</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../ds/index.html"> 
<span class="menu-text">Data Science</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../dp/index.html"> 
<span class="menu-text">Data Philosophy</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
    <a href="https://github.com" title="Github" class="quarto-navigation-tool px-1" aria-label="Github"><i class="bi bi-github"></i></a>
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">String Theory: Unraveling the Secrets of Textual Data with stringr</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Numbers around us </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">June 15, 2023</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p><img src="images/stringr.jpg" class="img-fluid"></p>
<p>In a world abundant with textual data, the need to unravel its secrets has become paramount. Words and characters weave intricate narratives, hold valuable insights, and shape the way we understand information. Like a cosmic web of knowledge, textual data stretches across various domains, from social media posts and customer reviews to scientific literature and news articles. Within this vast expanse of textual information lies the potential to extract valuable insights and make informed decisions.</p>
<p>However, working with textual data comes with its challenges. Strings, the building blocks of text, require careful manipulation and analysis to unlock their hidden patterns and uncover meaningful information. This is where the powerful tool of <code>stringr</code> comes into play — the wordsmith of textual data analysis.</p>
<p>Think of <code>stringr</code> as a skilled physicist peering into the cosmic tapestry of textual data, equipped with a toolkit designed to understand and manipulate strings with precision. Just as a physicist delves into the depths of the universe to decipher its mysteries, <code>stringr</code> empowers data scientists to explore, extract, and analyze the secrets hidden within strings of text.</p>
<p>With <code>stringr</code> as your trusted companion, you embark on a journey of discovery, traversing the vast cosmos of textual data. Armed with a toolkit built specifically for manipulating strings, you gain the ability to unravel the complexities, extract valuable insights, and transform raw text into actionable information.</p>
<p>Throughout this article, we will explore the immense universe of textual data, akin to a cosmic tapestry waiting to be unraveled. Guided by the power of <code>stringr</code>, we will dive into the depths of pattern matching, extraction, manipulation, and uncovering hidden secrets within textual data.</p>
<p>Join us as we embark on this cosmic journey of “String Theory” — a journey that promises to unravel the secrets of textual data and empower you to become a textual physicist, harnessing the power of <code>stringr</code> to extract valuable insights from the vast expanse of textual information.</p>
<p>Get ready to embark on an adventure where words and characters transform into valuable knowledge. Let us dive into the intricacies of “String Theory” and discover the immense potential of textual data analysis with <code>stringr</code> by our side.</p>
<section id="the-cosmos-of-textual-data" class="level2">
<h2 class="anchored" data-anchor-id="the-cosmos-of-textual-data">The Cosmos of Textual Data</h2>
<p>In the vast expanse of the digital universe, textual data reigns supreme. Every day, an unfathomable amount of text is generated through social media posts, emails, news articles, scientific papers, and more. This immense volume of textual information holds within it a wealth of knowledge, opinions, sentiments, and insights waiting to be discovered.</p>
<p>Imagine the cosmos of textual data as a celestial web, interconnecting ideas, thoughts, and experiences across various domains and languages. Just as astronomers gaze at the night sky, data scientists peer into this vast expanse of textual data, seeking to understand its intricacies and extract meaningful insights.</p>
<p>Within this cosmic tapestry, strings of characters serve as the building blocks of text. These strings, representing words, sentences, or even entire documents, hold the key to unlocking the secrets and patterns hidden within textual data. However, the sheer volume and complexity of textual information pose significant challenges for analysis and interpretation.</p>
<p>To navigate the cosmic expanse of textual data, data scientists require specialized tools that can effectively handle strings, extract relevant information, and derive valuable insights. This is where the power of stringr comes into play — an essential toolset designed specifically for the manipulation and analysis of strings in R.</p>
<p>With <code>stringr</code> as your guiding star, you can traverse the celestial web of textual data, unraveling its mysteries, and extracting the knowledge it holds. By harnessing the capabilities of <code>stringr</code>, you gain the ability to work with strings efficiently, enabling you to explore patterns, identify trends, and gain a deeper understanding of textual information.</p>
<p>In the following sections, we will delve deeper into the capabilities of <code>stringr</code>, metaphorically embarking on a cosmic journey through “String Theory.” Together, we will uncover the secrets hidden within strings, manipulate and transform textual data, and emerge with newfound insights that can shape our understanding of the world.</p>
<p>Prepare to embark on an astronomical adventure where words and characters become celestial bodies, forming constellations of knowledge within the cosmic tapestry of textual data. With <code>stringr</code> as our guiding compass, we will navigate the vast expanse of the textual cosmos and unravel its hidden patterns and insights. So, brace yourself for a captivating exploration of the cosmos of textual data through the lens of “String Theory.”</p>
</section>
<section id="the-physicists-toolkit-introducing-stringr" class="level2">
<h2 class="anchored" data-anchor-id="the-physicists-toolkit-introducing-stringr">The Physicist’s Toolkit: Introducing stringr</h2>
<p>As we embark on our cosmic journey of “String Theory,” it is essential to equip ourselves with the right tools. Enter <code>stringr</code> — a powerful toolkit designed to navigate the vast expanse of textual data with precision and efficiency. Much like a physicist requires specialized instruments to study the cosmos, data scientists rely on stringr to manipulate, extract, and analyze strings effortlessly.</p>
<p><code>Stringr</code> serves as the fundamental toolkit for working with strings in the R programming language. It offers a comprehensive set of functions and methods that simplify the process of handling textual data. Just as a physicist carefully selects the instruments for a specific experiment, <code>stringr</code> provides you with the necessary tools to effectively work with strings in your data analysis tasks.</p>
<p>At the core of <code>stringr</code>’s toolkit lies its ability to perform pattern matching, extraction, replacement, and manipulation of strings. Whether you need to identify specific patterns, extract relevant information, or clean and transform text, <code>stringr</code> has you covered.</p>
<p>With functions like <code>str_extract()</code>, you can easily locate and extract specific patterns or substrings from your text. Imagine it as a cosmic magnifying glass, allowing you to zoom in on the precise elements you need.</p>
<p>For example, let’s say you have a dataset of movie titles, and you want to extract the years from each title. With <code>stringr</code>, you can effortlessly accomplish this task using regular expressions:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(stringr)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Example movie titles</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>movie_titles <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"The Shawshank Redemption (1994)"</span>, <span class="st">"Pulp Fiction (1994)"</span>, <span class="st">"The Dark Knight (2008)"</span>)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Extract the years from movie titles</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>years <span class="ot">&lt;-</span> <span class="fu">str_extract</span>(movie_titles, <span class="st">"</span><span class="sc">\\</span><span class="st">d{4}"</span>)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>years</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="co"># [1] "1994" "1994" "2008"</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In this code snippet, we use <code>str_extract()</code> along with a regular expression pattern (<code>\\d{4}</code>) to locate four consecutive digits (indicating the year) within each movie title. The result is an extracted vector of years, allowing us to gain insights specifically related to the temporal aspect of the movies.</p>
<p><code>Stringr</code>’s toolkit also includes functions like <code>str_replace()</code> and <code>str_detect()</code>, which enable you to replace specific patterns within strings or detect the presence of particular substrings, respectively. These functions act as versatile instruments in your textual physicist’s toolbox, allowing you to manipulate and analyze strings with ease.</p>
<p>As we continue our journey through “String Theory,” the capabilities of stringr will become increasingly apparent. With its arsenal of functions and methods, stringr empowers you to navigate the cosmic expanse of textual data, extracting valuable information and unraveling the intricate patterns hidden within strings.</p>
<p>Prepare to witness the power of <code>stringr</code> as it transforms your approach to textual data analysis. Just as a physicist’s toolkit enables the exploration of the cosmos, stringr equips you to delve into the celestial wonders of textual data, uncovering its secrets, and illuminating the path to valuable insights.</p>
<p>Get ready to wield the tools of a textual physicist as we venture deeper into the cosmic tapestry of textual data analysis with <code>stringr</code> as our guiding star.</p>
</section>
<section id="navigating-the-textual-universe-exploring-stringrs-functions" class="level2">
<h2 class="anchored" data-anchor-id="navigating-the-textual-universe-exploring-stringrs-functions">Navigating the Textual Universe: Exploring stringr’s Functions</h2>
<p>As we venture further into the cosmic expanse of textual data, we encounter the need for powerful tools to navigate and explore this vast universe of strings. Here enters <code>stringr</code>, with its arsenal of functions and methods that make working with strings in R a breeze. With <code>stringr</code> as our guiding star, let us delve into the depths of its functions and embark on a journey of discovery.</p>
<p><strong>Pattern Matching with <code>str_extract()</code>:</strong></p>
<p>Stringr offers a powerful function called <code>str_extract()</code> that allows us to locate and extract specific patterns or substrings from our text. Think of it as a cosmic magnifying glass, enabling us to zoom in on the precise elements we seek within the vastness of textual data.</p>
<p>For example, let’s say we have a dataset of customer reviews, and we want to extract all the email addresses mentioned within those reviews. With <code>str_extract()</code>, we can easily accomplish this task:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(stringr) </span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Example customer reviews</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>customer_reviews <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"Great product! Email me at example@gmail.com for further inquiries."</span>, <span class="st">"Contact us via support@example.com for any assistance."</span>)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Extract email addresses from customer reviews</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>email_addresses <span class="ot">&lt;-</span> <span class="fu">str_extract</span>(customer_reviews, <span class="st">"</span><span class="sc">\\</span><span class="st">b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+</span><span class="sc">\\</span><span class="st">.[A-Za-z]{2,}</span><span class="sc">\\</span><span class="st">b"</span>)</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>email_addresses</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="co"># [1] "example@gmail.com"   "support@example.com"</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In this code snippet, we use <code>str_extract()</code> along with a regular expression pattern to locate and extract email addresses from the customer reviews. The result is a vector containing the extracted email addresses, allowing us to analyze and utilize this information effectively.</p>
<p><strong>String Replacement with <code>str_replace()</code>:</strong></p>
<p>Sometimes, we encounter the need to replace specific patterns within our strings. <code>Stringr</code>’s <code>str_replace()</code> function comes to our rescue, acting as a cosmic tool for seamless string replacement.</p>
<p>Consider a scenario where we want to sanitize a dataset of tweets by replacing all instances of profanity with asterisks. Here’s how we can accomplish this using <code>str_replace()</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(stringr) </span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Example tweets with bad word duck :D</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>tweets <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"This movie is ducking amazing! #bestmovieever"</span>,</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>            <span class="st">"I can't believe how ducked the service was. #disappointed"</span>)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Replace profanity with asterisks</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>sanitized_tweets <span class="ot">&lt;-</span> <span class="fu">str_replace</span>(tweets, <span class="st">"</span><span class="sc">\\</span><span class="st">bduck"</span>, <span class="st">"****"</span>)</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>sanitized_tweets</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="co"># [1] "This movie is ****ing amazing! #bestmovieever"            </span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="co"># [2] "I can't believe how ****ed the service was. #disappointed"</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The pattern is replaced with four asterisks, effectively censoring the profanity within the tweets.</p>
<p><strong>String Detection with <code>str_detect()</code>:</strong></p>
<p>Another useful function in <code>stringr</code>’s cosmic toolbox is <code>str_detect()</code>. This function allows us to detect the presence of specific substrings within our strings, enabling us to filter or perform conditional operations based on the detected patterns.</p>
<p>Suppose we have a dataset of customer feedback and want to identify which comments mention the word “excellent”. We can achieve this using <code>str_detect()</code>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(stringr) </span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Example customer feedback</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>customer_feedback <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"The service was excellent and the staff was friendly."</span>,</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="st">"I had a terrible experience and won’t recommend this place."</span>)</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Detect comments mentioning “excellent”</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>excellent_mentions <span class="ot">&lt;-</span> <span class="fu">str_detect</span>(customer_feedback, <span class="st">"</span><span class="sc">\\</span><span class="st">bexcellent</span><span class="sc">\\</span><span class="st">b"</span>)</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="co"># [1]  TRUE FALSE</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>By using <code>str_detect()</code> with a regular expression pattern, we identify which comments contain the exact word “excellent”. The result is a logical vector indicating the presence or absence of “excellent” mentions within each feedback entry.</p>
<p>With these examples, we catch a glimpse of <code>stringr</code>’s celestial power in manipulating, extracting, and detecting patterns within textual data. These functions serve as versatile instruments in the textual physicist’s toolkit, allowing us to navigate the vast textual universe and derive insights from its interwoven strings.</p>
<p>Continue the cosmic journey of “String Theory” as we explore advanced techniques and uncover hidden patterns within the cosmic tapestry of textual data using stringr.</p>
</section>
<section id="unveiling-hidden-patterns-advanced-techniques-with-stringr" class="level2">
<h2 class="anchored" data-anchor-id="unveiling-hidden-patterns-advanced-techniques-with-stringr">Unveiling Hidden Patterns: Advanced Techniques with stringr</h2>
<p>As we traverse deeper into the cosmic tapestry of textual data, we encounter the need for more advanced techniques to unveil the intricate patterns hidden within strings. Luckily, <code>stringr</code> equips us with a range of capabilities and tools to explore these hidden gems. Let’s dive into the realm of advanced techniques with <code>stringr</code> and witness the cosmic revelations they unveil.</p>
<p><strong>Harnessing the Power of Regular Expressions:</strong></p>
<p>One of the most powerful features of <code>stringr</code> is its integration with regular expressions. Regular expressions act as a cosmic language for pattern matching and manipulation within strings. By utilizing the expressive syntax of regular expressions, we can unlock a myriad of possibilities for uncovering complex patterns and extracting valuable information from textual data.</p>
<p>For example, let’s say we have a dataset of news headlines and we want to extract the important keywords from each headline. By leveraging the cosmic power of regular expressions, we can achieve this with ease using <code>str_extract()</code>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(stringr)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Example news headlines</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>headlines <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"Scientists Discover New Species of Exoplanets"</span>, <span class="st">"Breaking: Global Pandemic Update"</span>, <span class="st">"Tech Giant Unveils Revolutionary AI Technology"</span>)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Extract important keywords from headlines</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>keywords <span class="ot">&lt;-</span> <span class="fu">str_extract</span>(headlines, <span class="st">"</span><span class="sc">\\</span><span class="st">b[A-Z][a-z]+</span><span class="sc">\\</span><span class="st">b"</span>)</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>keywords</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="co"># [1] "Scientists" "Breaking"   "Tech"    </span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In this code snippet, the regular expression pattern (<code>\\b[A-Z][a-z]+\\b</code>) allows us to extract the important keywords from each headline by matching capitalized words. The resulting <code>keywords</code> vector provides us with a cosmic glimpse into the essence of each news headline.</p>
<p><strong>String Manipulation with Functions:</strong></p>
<p><code>Stringr</code> provides a suite of functions that enable sophisticated string manipulation, allowing us to transform and reshape textual data. These functions act as cosmic tools for manipulating strings, enabling us to extract valuable insights from the vast cosmic web of textual information.</p>
<p>For instance, suppose we have a dataset of customer reviews, and we want to remove all punctuation marks to perform sentiment analysis. <code>Stringr</code>’s <code>str_remove_all()</code> function can help us achieve this:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(stringr)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Example customer reviews</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>reviews <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"This product is amazing!"</span>, <span class="st">"Horrible customer service!!!"</span>, <span class="st">"I love it!!!"</span>)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Remove punctuation marks from reviews</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>clean_reviews <span class="ot">&lt;-</span> <span class="fu">str_remove_all</span>(reviews, <span class="st">"[[:punct:]]"</span>)</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>clean_reviews</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="co"># [1] "This product is amazing"   "Horrible customer service" "I love it" </span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Using the regular expression pattern <code>[[:punct:]]</code>, <code>str_remove_all()</code> effectively removes all punctuation marks from the reviews. This cosmic transformation allows us to focus solely on the words and sentiments expressed in the customer feedback.</p>
<p><strong>Exploring Textual Boundaries with <code>str_split()</code>:</strong></p>
<p>In the cosmic realm of textual data, we often encounter the need to split strings based on specific delimiters or boundaries. <code>Stringr</code>’s <code>str_split()</code> function provides us with a cosmic compass to navigate these boundaries and extract valuable components from strings.</p>
<p>Imagine we have a dataset of email addresses, and we want to separate the username and domain name. We can effortlessly achieve this using <code>str_split()</code>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(stringr)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Example email addresses</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>emails <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"john.doe@example.com"</span>, <span class="st">"jane.smith@gmail.com"</span>, <span class="st">"mark.wilson@yahoo.com"</span>)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Split email addresses into username and domain</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>split_emails <span class="ot">&lt;-</span> <span class="fu">str_split</span>(emails, <span class="st">"@"</span>)</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>split_emails </span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="co"># [[1]]</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="co"># [1] "john.doe"    "example.com"</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="co"># [[2]]</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a><span class="co"># [1] "jane.smith" "gmail.com" </span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a><span class="co"># [[3]]</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a><span class="co"># [1] "mark.wilson" "yahoo.com" </span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>With <code>str_split()</code> and the delimiter <code>@</code>, we split each email address into two components — the username and the domain. The resulting <code>split_emails</code> list provides us with a cosmic separation of these essential elements.</p>
<p>By exploring the advanced techniques offered by <code>stringr</code>, we transcend the boundaries of traditional textual analysis and embrace the cosmic revelations hidden within strings. These techniques empower us to unravel the intricate patterns, transform the data, and gain deeper insights into the cosmic web of textual information.</p>
<p>As our cosmic journey through “String Theory” continues, we invite you to further explore these advanced techniques with <code>stringr</code>. Witness the cosmic power of regular expressions, manipulate strings with precision, and navigate the celestial boundaries of textual data, unraveling its hidden secrets one cosmic revelation at a time.</p>
</section>
<section id="the-grand-discovery-putting-it-all-together" class="level2">
<h2 class="anchored" data-anchor-id="the-grand-discovery-putting-it-all-together">The Grand Discovery: Putting it All Together</h2>
<p>After traversing the cosmic expanse of textual data and delving into the advanced techniques offered by <code>stringr</code>, it’s time to bring our discoveries together and witness the grand revelation that awaits us. By integrating the knowledge gained and leveraging the power of <code>stringr</code>, we can unlock a deeper understanding of textual data and embark on a journey of meaningful insights.</p>
<p><strong>A Comprehensive Analysis Workflow:</strong></p>
<p>To fully harness the cosmic potential of <code>stringr</code>, it is essential to embrace a comprehensive analysis workflow. Start by preprocessing your textual data, cleaning and transforming it to ensure accuracy and consistency. <code>Stringr</code>’s functions, such as <code>str_replace()</code> and <code>str_remove_all()</code>, prove invaluable in this stage, allowing you to remove unwanted elements and refine the data.</p>
<p>Next, apply the <code>stringr</code> toolkit to extract relevant patterns, keywords, or entities from your text. Utilize functions like <code>str_extract()</code> or <code>str_detect()</code> to uncover valuable insights that may be hidden within the strings. Cosmic revelations await those who can decipher the patterns and meaning concealed within the vast cosmic tapestry of textual data.</p>
<p>Remember, analysis is an iterative process. Refine your techniques, experiment with different patterns, and explore the celestial boundaries of textual data. The power of <code>stringr</code> lies not only in its individual functions but also in the creative combinations and transformations that can be applied to extract deeper insights.</p>
<p><strong>Unleashing the Power of Visualization:</strong></p>
<p>Visualization acts as a cosmic lens, allowing us to perceive the patterns and relationships within textual data. Once you have manipulated and extracted relevant information using <code>stringr</code>, employ visualization techniques to bring the insights to life.</p>
<p>Consider generating word clouds, bar charts, or network visualizations to highlight the most frequent words, key entities, or connections within your textual data. By visualizing the cosmic web of text, you can communicate your findings effectively and uncover additional insights that may have been overlooked.</p>
<p><strong>Embracing the Role of the Textual Physicist:</strong></p>
<p>As a data scientist traversing the cosmic realms of textual data with <code>stringr</code> as your cosmic compass, embrace your role as a textual physicist. Just as physicists explore the mysteries of the universe, you explore the mysteries of language and meaning within textual data.</p>
<p>Continuously expand your cosmic toolkit, enhance your understanding of regular expressions, and experiment with different functions and techniques offered by stringr. Embrace the iterative nature of analysis and the inherent curiosity that drives cosmic exploration. With each revelation, you further uncover the cosmic truths embedded within strings of text.</p>
<p>In this cosmic journey of “String Theory,” we have traversed the vast expanse of textual data, armed with the powerful tools and techniques provided by <code>stringr</code>. We have witnessed the cosmic potential of regular expressions, harnessed the transformative power of string manipulation, and explored the celestial boundaries of textual data.</p>
<p>As you continue your exploration of textual data, remember that <code>stringr</code> is your loyal companion, guiding you through the cosmic web of strings and unraveling the secrets within. By following a comprehensive analysis workflow, unleashing the power of visualization, and embracing your role as a textual physicist, you embark on a journey of grand discoveries and profound insights.</p>
<p>So, equip yourself with the celestial toolkit of <code>stringr</code>, venture into the cosmic realms of textual data, and unlock the mysteries that lie within the strings. The cosmic revelations await those who dare to explore the depths of “String Theory” with <code>stringr</code> as their cosmic guide.</p>
<p>Embrace the power of <code>stringr</code>, unravel the cosmic tapestry of textual data, and illuminate the path to profound insights.</p>
<p>May your cosmic journey through the realms of textual data be filled with discovery, enlightenment, and cosmic revelations!</p>
</section>
<section id="post-scriptum-harnessing-the-cosmic-power-of-regular-expressions-with-chatgpt" class="level2">
<h2 class="anchored" data-anchor-id="post-scriptum-harnessing-the-cosmic-power-of-regular-expressions-with-chatgpt">Post Scriptum: Harnessing the Cosmic Power of Regular Expressions with ChatGPT</h2>
<p>Unleashing the full potential of <code>stringr</code> and regular expressions can be an empowering journey. If you ever find yourself in need of assistance with crafting regular expressions, ChatGPT can be your celestial guide.</p>
<p>Simply engage in a conversation with ChatGPT and describe the pattern you are seeking to match or extract. For instance, if you want to extract email addresses, provide ChatGPT with a prompt like, “I need a regular expression to capture email addresses.” ChatGPT will respond with a suggested regular expression that fits your requirements, accelerating your exploration of the cosmic web of strings.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>Example<span class="sc">:</span> </span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>Prompt<span class="sc">:</span> “I need a regular expression to capture email addresses.” </span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>Response<span class="sc">:</span> “<span class="sc">^</span>\b[A<span class="sc">-</span>Za<span class="sc">-</span>z0–<span class="fl">9.</span>_%<span class="sc">+-</span>]<span class="sc">+</span><span class="er">@</span>[A<span class="sc">-</span>Za<span class="sc">-</span>z0–<span class="fl">9.</span><span class="sc">-</span>]<span class="sc">+</span>\.[A<span class="sc">-</span>Za<span class="sc">-</span>z]{<span class="dv">2</span>,}\b<span class="sc">$</span>” </span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>Let’s <span class="cf">break</span> down the components of this regular expression<span class="sc">:</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>\b                 indicates a word boundary, ensuring that the match occurs at the beginning and end of the email address.</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>[A<span class="sc">-</span>Za<span class="sc">-</span>z0<span class="fl">-9.</span>_%<span class="sc">+-</span>]<span class="sc">+</span>  matches one or more alphanumeric characters, dots, underscores, percentage signs, plus signs, or hyphens, representing the local part of the email address before the <span class="sc">@</span> symbol.</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="sc">@</span>                  matches the <span class="sc">@</span> symbol.</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>[A<span class="sc">-</span>Za<span class="sc">-</span>z0<span class="fl">-9.</span><span class="sc">-</span>]<span class="sc">+</span>     matches one or more alphanumeric characters, dots, or hyphens, representing the domain name.</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>\.                 matches a <span class="fu">dot</span> (.), which separates the domain name from the top<span class="sc">-</span>level <span class="fu">domain</span> (TLD).</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>[A<span class="sc">-</span>Za<span class="sc">-</span>z]{<span class="dv">2</span>,}       matches two or more alphabetical characters, representing the TLD.</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>\b indicates a word boundary at the end of the email address.</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>By leveraging ChatGPT’s linguistic capabilities, you can tap into its cosmic wisdom to generate regular expressions that align with your data analysis goals. Embrace the celestial synergy between human creativity and AI assistance as you navigate the intricate cosmic patterns of textual data.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = true;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p>For everybody, not to be fooled by numbers</p>
</div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>